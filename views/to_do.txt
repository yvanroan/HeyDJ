next thing here is to be able to communicate with my database. 
like being able to add the users,djs, songs and request to my db.
being able to communicate pull and push to the db in real time.

i created a fetch function which will update the website each time we make 
a change to the db. still need to finish it tho, not everything is updated
yet. the stack, the history are not updated.

if we remove or play a request, hte status should go to True
we can try adding the ids of the dj and song, turn it into a number and
compare it with the ones we have previously stored to find if the song has been
sent by another user before. 

why not make a poll after to see which song were the most requested after the party
would be pretty easy actually 

create the session entity

create the ref_request id which will be for request with the same song and dj.
a new request will always be created, but we will go through the stack to see if there is a request
that has the same song and dj as the new one we want to create. if it exist, we will just update the
ask parameter of the new request.

when you are sending request withthe same ref_request id and the session is ended, 
if a new session start and the same ref_request id is used, then your ask will have to 
be zero from there. answer: the ref_request will have in_stack: false so will not be used by the app.

in the far future we will let users be able to cancel request they send, when we implement money.



We just created the event table and i am trying to integrate it in the workflow, what i want is
"
Given that the Dj starts the event, we need the MAIN_DJ to create the event( and let other dj join
if necessary). after that, we load the session for the users with available songs and djs. 
and everything is good, but when the user submit a request or the dj accepts a request, we need to update
and refetch all the data we need. so we need 


think about how you are going to implement main dj and side dj for a single session.
but i do not want one dj to have many session, a DJ CANNOT BE IN TWO SESSION AT THE SAME TIME.

so we want to create a database or system such that each session has a main dj from the dj table (and 
possibly other dj which will get permission from the main dj, FUTURE) but we do not want the dj to have
the ability to be in two session at once at the same time ( might have to incorporate a start and end time
for the session to do this) and the whole session needs to constantly need the event id to operate( fetch data)
so there will be a limited list of dj, song all, user all and whatever.

make sure that the event id created at the beginning persist despite reload and use it during every fetch_data
to the api. technically the users are sending all their request to the main dj of the party.

i need to create 3 pages that i can open separately(later)

- start a event and provide main_dj id(after login)
- we keep main_dj and event id through out the interaction and get data using this. dj can have thier stack here
    accept or deny requests. you can get out if you end the event.
- User side can only see the songs, and the dj (after login)


create an object that will contain all the request that have to be shown since we dont want duolicates.

******** maybe adding the foreign key constraint wasnt working well here because when i create it, the database is trying
to find that foreign key in entries that do not have them and it causes an error. **********

divide the pages into three different servers which will work together 

eman wants a feature that let people now if they are next in the dj's queue

check if lastfm save title the same way shazam does. verify with this
['Tuesday (feat. Drake)', 'iLoveMakonnen']

***prevent sql injection in your code*** apparently using orm makes thing better against data injection
so using orm payed off

now we have to be able to create users from the page, and deal with authentication.


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

the reason why you weren't able to install in your venv was because the path that pip is using for the
installation is that of our local(global).

you need to make sure that you activated your venv then you do 'which pip' to see where it points, if 
it points towards another directory, do this 'export PATH="/home/yvan/Desktop/projects/project_name/venv/bin:$PATH" '

if it points towards you already just delete your venv and create a new one, and create a requirements.txt with all 
the imports you need

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++